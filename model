import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import precision_score, recall_score
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import CountVectorizer
from fuzzywuzzy import fuzz
from metaphone import doublemetaphone
from jellyfish import soundex

# Load data from Excel
file_path = 'Mathwizzathon_Entity_Matching_Dataset.xlsx'  # Replace with your Excel file path
data = pd.read_excel(file_path)

# List of common titles and honorifics to ignore
titles = {'dr', 'mr', 'mrs', 'ms', 'ph.d.', 'professor', 'sir', 'lady', 'captain', 'major'}

# Preprocessing functions
def normalize_name(name):
    return str(name).lower().replace(".", "").replace("-", "").replace(",", "").strip()

def remove_titles(name):
    parts = normalize_name(name).split()
    return ' '.join(part for part in parts if part not in titles)

def phonetic_encoding(name):
    encoded = doublemetaphone(name)
    return encoded[0] if encoded[0] else encoded[1]

def soundex_encoding(name):
    return soundex(name)

def calculate_similarity_features(name1, name2):
    name1, name2 = normalize_name(name1), normalize_name(name2)
    name1_no_titles = remove_titles(name1)
    name2_no_titles = remove_titles(name2)

    phonetic_sim = fuzz.ratio(phonetic_encoding(name1_no_titles), phonetic_encoding(name2_no_titles)) / 100.0
    levenshtein_sim = fuzz.ratio(name1_no_titles, name2_no_titles) / 100.0
    cosine_sim = cosine_similarity(
        CountVectorizer(analyzer='char', ngram_range=(2, 3)).fit_transform([name1_no_titles, name2_no_titles])
    )[0][1]
    
    return phonetic_sim, levenshtein_sim, cosine_sim

# Train data for the ML model
train_data = pd.DataFrame({
    'name1': ['samuel gabrial cartar', 'jerrie edwards', 'john doe', 'jane smith'],
    'name2': ['s gc', 'jerry edwards', 'jon doe', 'j smith'],
    'label': [1, 1, 1, 1]  # 1 indicates similar, 0 indicates not similar
})

# Extract features for training
train_data[['phonetic_sim', 'levenshtein_sim', 'cosine_sim']] = train_data.apply(
    lambda row: pd.Series(calculate_similarity_features(row['name1'], row['name2'])), axis=1
)

# Train the ML model
X_train = train_data[['phonetic_sim', 'levenshtein_sim', 'cosine_sim']]
y_train = train_data['label']
model = RandomForestClassifier()
model.fit(X_train, y_train)

# Calculate final score using both heuristic and ML model
def final_score(name1, name2):
    phonetic_sim, levenshtein_sim, cosine_sim = calculate_similarity_features(name1, name2)
    
    # Calculate heuristic score
    heuristic_score = (0.25 * phonetic_sim + 0.25 * levenshtein_sim + 0.50 * cosine_sim)
    
    # Predict using ML model
    features = pd.DataFrame([[phonetic_sim, levenshtein_sim, cosine_sim]], columns=['phonetic_sim', 'levenshtein_sim', 'cosine_sim'])
    ml_score = model.predict_proba(features)[:, 1][0]  # Probability of similarity
    
    # Combine scores with weights
    combined_score = 0.5 * heuristic_score + 0.5 * ml_score
    return combined_score

# Matching function
def match_names_from_excel(data, threshold=0.6):
    results = []
    for _, row in data.iterrows():
        name1, name2 = row['Name1'], row['Name2']
        score = final_score(name1, name2)
        label = 1 if score >= threshold else 0
        results.append((name1, name2, score, label))
    
    results_df = pd.DataFrame(results, columns=["Name1", "Name2", "Similarity Score", "Predicted Label"])
    return results_df

# Run the matching and store the results
matched_df = match_names_from_excel(data, threshold=0.6)

# Add actual labels to the matched results for comparison
matched_df['Actual Label'] = data['Label']

# Calculate accuracy, precision, and recall
accuracy = (matched_df['Predicted Label'] == matched_df['Actual Label']).mean() * 100
precision = precision_score(matched_df['Actual Label'], matched_df['Predicted Label'])
recall = recall_score(matched_df['Actual Label'], matched_df['Predicted Label'])

# Identify mismatches
mismatches = matched_df[matched_df['Predicted Label'] != matched_df['Actual Label']]

# Print mismatched rows
if not mismatches.empty:
    print("Mismatches between Actual and Predicted Labels:")
    print(mismatches)
else:
    print("All predictions match the actual labels.")

# Save mismatches to a separate Excel file
mismatches_file_path = 'mismatched_names_output.xlsx'
mismatches.to_excel(mismatches_file_path, index=False)

# Save results to a new Excel file
output_file_path = 'matched_names_output.xlsx'
matched_df.to_excel(output_file_path, index=False)

print(f"Matched names saved to '{output_file_path}'")
print(f"Mismatched names saved to '{mismatches_file_path}'")
print(f"Accuracy: {accuracy:.2f}%")
print(f"Precision: {precision:.2f}")
print(f"Recall: {recall:.2f}")
