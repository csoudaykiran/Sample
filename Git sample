import pytest
from unittest import mock
import time

# Assuming the custom_retry decorator is in a file called custom_retry.py
from custom_retry import custom_retry

# Mock function for testing
def mock_func(success=True):
    if not success:
        return False
    return True

# Test the decorator with mock_func
def test_custom_retry_success():
    # Test if the function succeeds on the first try (no retries)
    @custom_retry(max_retries=3, time_gap=1)
    def decorated_func():
        return mock_func(success=True)
    
    result = decorated_func()
    
    # Ensure the result is True since the function should succeed
    assert result is True

def test_custom_retry_failure():
    # Test if the function retries correctly and eventually fails
    @custom_retry(max_retries=3, time_gap=1)
    def decorated_func():
        return mock_func(success=False)
    
    result = decorated_func()
    
    # Ensure the result is False after max_retries have been exceeded
    assert result is False

def test_custom_retry_retries():
    # Test if the function retries the expected number of times
    @custom_retry(max_retries=3, time_gap=1)
    def decorated_func():
        return mock_func(success=False)
    
    # Use mock to ensure time.sleep is called during retries
    with mock.patch('time.sleep') as mock_sleep:
        decorated_func()
        # Ensure time.sleep was called the correct number of times
        assert mock_sleep.call_count == 3

def test_custom_retry_max_retries():
    # Test if max_retries is respected (the function retries the correct number of times)
    @custom_retry(max_retries=2, time_gap=1)
    def decorated_func():
        return mock_func(success=False)
    
    result = decorated_func()
    assert result is False  # Should return False after 2 retries
